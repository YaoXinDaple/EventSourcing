## 事件溯源

优势：
1.回溯任意时间点的实体状态
2.高性能写：持久化都是追加，不修改
3.伸缩性：聚合读写容易伸缩，进而整个业务系统都容易伸缩
4.细颗粒度排障：观察领域模型状态的变化过程来排障
5.不需要考虑聚合持久化，模型设计不需要考虑存储实现

限制：
1.必须设计可回溯的模型，保证可以重建聚合
2.必须CQRS
3.重建能力需要编码实现

实现事件溯源的前提：
模型设计达到聚合完备才能可溯源

实现：
持久化领域事件
仓储的保存功能可以废弃掉
查询方法：按id查询，或者提前构建索引，先查出id，再按id查出聚合
快照：
聚合事件可能较多，导致重建性能差时使用
每发生过一些事件，保存聚合所有状态到快照中
仓储查询时间最近的聚合，再根据事件重建聚合

新建快照的时机：
定时任务
保存领域事件时
读取聚合时
快照策略：
快照后领域事件数量达到某个阈值
发生某种事件后
最近N次重建时间超过阈值
距离上次快照时间间隔多久后


事件溯源有必要时采用：
1. 高性能写
2. 需要严格审计（回溯任意时间实体状态）
3. 穿越
4. 排障
5. 建模更自由










## 事件溯源的示例代码 (AI提示词)

你是一个领域驱动设计（DDD）和事件溯源（Event Sourcing）的专家。请根据以下要求编写一个简单的示例代码，展示如何使用事件溯源来管理一个银行账户的状态。

要求：
1. 定义一个 `BankAccount` 聚合根，包含账户ID和余额。
2. 定义一个 `DepositMoney` 命令，用于存款操作。
3. 定义一个 `MoneyDeposited` 事件，表示存款已完成。
4. 定义一个 `WithDrawMoney` 命令，用于取款操作。
5. 定义一个 `MoneyWithdrawn` 事件，表示取款已完成。
4. 实现一个事件存储，用于保存和加载事件，使用EFCore。
5. 实现一个命令处理器，用于处理 `DepositMoney` 命令并生成相应的事件。
6. 实现一个事件处理器，用于应用 `MoneyDeposited` 事件并更新账户余额。
7. 定义一个 `GetAccountBalance` 查询，用于获取当前账户余额。
8. 定义领域命令和领域事件的基类。让命令和事件继承这些基类。
9. `BankAccount`聚合根需要支持从事件流中重建其状态。
10. `BankAccount` 聚合根需要定义一个接口用于判断是否需要创建新的快照。这个接口可以根据事件数量或时间间隔来决定是否创建快照。分别实现基于事件数量和时间间隔的快照策略。
11. 实现一个快照存储，用于保存和加载快照，使用EFCore。
12. 基于快照和事件可以指定任意时间点回溯账户状态。
13. 创建WebApi接口，支持存款、取款和查询余额、回溯状态操作。






### 技术栈 使用 Net10 以及C#语言最新版本编写代码。使用 Entity Framework Core 作为 ORM 框架。
